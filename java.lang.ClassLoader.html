<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>ClassLoader</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_classloader">1. ClassLoader</a>
<ul class="sectlevel2">
<li><a href="#_参考资料">1.1. 参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_classloader"><a class="anchor" href="#_classloader"></a>1. ClassLoader</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然对 <code>ClassLoader</code> 的双亲委派流程比较了解，但是一直没有仔细专研过代码实现。今天翻看代码，代码写的简单明了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * Loads the class with the specified &lt;a href="#binary-name"&gt;binary name&lt;/a&gt;.  The
 * default implementation of this method searches for classes in the
 * following order:
 *
 * &lt;ol&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) loadClass} method
 *   on the parent class loader.  If the parent is {@code null} the class
 *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 *   class.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; If the class was found using the above steps, and the
 * {@code resolve} flag is true, this method will then invoke the {@link
 * #resolveClass(Class)} method on the resulting {@code Class} object.
 *
 * &lt;p&gt; Subclasses of {@code ClassLoader} are encouraged to override {@link
 * #findClass(String)}, rather than this method.  &lt;/p&gt;
 *
 * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 * {@link #getClassLoadingLock getClassLoadingLock} method
 * during the entire class loading process.
 *
 * @param  name
 *         The &lt;a href="#binary-name"&gt;binary name&lt;/a&gt; of the class
 *
 * @param  resolve
 *         If {@code true} then resolve the class
 *
 * @return  The resulting {@code Class} object
 *
 * @throws  ClassNotFoundException
 *          If the class could not be found
 */
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}

/**
 * Finds the class with the specified &lt;a href="#binary-name"&gt;binary name&lt;/a&gt;.
 * This method should be overridden by class loader implementations that
 * follow the delegation model for loading classes, and will be invoked by
 * the {@link #loadClass loadClass} method after checking the
 * parent class loader for the requested class.
 *
 * @implSpec The default implementation throws {@code ClassNotFoundException}.
 *
 * @param  name
 *         The &lt;a href="#binary-name"&gt;binary name&lt;/a&gt; of the class
 *
 * @return  The resulting {@code Class} object
 *
 * @throws  ClassNotFoundException
 *          If the class could not be found
 *
 * @since  1.2
 */
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果自定义 <code>ClassLoader</code>，最简单的办法就是重载 <code>Class&lt;?&gt; findClass(String name)</code> 方法就可以了。或者为了避免双亲委托机制，可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.util.Objects;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-03-10 17:23
 */
public class ClassLoaderTest {
    public static void main(String[] args) {
        System.out.println("ClassLodarDemo's ClassLoader is " + ClassLoaderTest.class.getClassLoader());
        System.out.println("The Parent of ClassLodarDemo's ClassLoader is " + ClassLoaderTest.class.getClassLoader().getParent());
        System.out.println("The GrandParent of ClassLodarDemo's ClassLoader is " + ClassLoaderTest.class.getClassLoader().getParent().getParent());
    }

    @Test
    public void test() throws ClassNotFoundException, NoSuchMethodException,
            IllegalAccessException, InvocationTargetException,
            InstantiationException {
        DiguageClassLoader loader = new DiguageClassLoader();
        // 如何识别内部类？
        // 如何获取内部类的正确类名？
        Class&lt;?&gt; clazz = loader.loadClass(
                "com.diguage.truman.ClassLoaderTest.HelloWorld");
        Object instance = clazz.getDeclaredConstructor().newInstance();
        System.out.println(instance.toString());
    }

    public static class HelloWorld {
        @Override
        public String toString() {
            return "Hello, https://www.diguage.com/";
        }
    }

    public static class DiguageClassLoader extends ClassLoader {
        @Override
        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
            if (Objects.isNull(name)) {
                throw new IllegalArgumentException("class name is null.");
            }
            String fileName = name.replaceAll("\\.", "/") + ".class";
            int index = fileName.lastIndexOf("/");
            fileName = fileName.substring(0, index) + "$"
                    + fileName.substring(index + 1);
            InputStream inputStream = getResourceAsStream(fileName);
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            try {
                int size = 0;
                byte[] bytes = new byte[1024];
                while ((size = inputStream.read(bytes)) != -1) {
                    outputStream.write(bytes, 0, size);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            byte[] bytecodes = outputStream.toByteArray();
            if (bytecodes.length == 0) {
                throw new ClassNotFoundException(name);
            }
            int i = name.lastIndexOf(".");
            String className = name.substring(0, i) + "$" + name.substring(i + 1);
            return defineClass(className, bytecodes, 0, bytecodes.length);
        }
    }
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>jdk.internal.loader.ClassLoaders.PlatformClassLoader</code></p>
</li>
<li>
<p><code>jdk.internal.loader.ClassLoaders.AppClassLoader</code></p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./diag-ef52046d7364e83d0b5a63f62cc3844a.svg" alt="diag ef52046d7364e83d0b5a63f62cc3844a" width="100%" height="250">
</div>
<div class="title">Figure 1. JDK 8 及以前的加载体系</div>
</div>
<div class="paragraph">
<p>在 JDK 8 及以前，<code>AppClassLoader</code> 和 <code>ExtClassLoader</code> 这两个类都是 <code>sun.misc.Launcher</code> 中的内部类。 <code>BootstrapClassLoader</code> 是由 C++ 代码实现的。所以，不存在 Java 类定义。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/load-class-process.png" alt="load class process">
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./diag-591951bddf42ea19b935b551f129c9ee.svg" alt="diag 591951bddf42ea19b935b551f129c9ee" width="100%" height="250">
</div>
<div class="title">Figure 2. JDK 9 之后的加载体系</div>
</div>
<div class="paragraph">
<p>在 JDK 9 以后，<code>AppClassLoader</code>，<code>PlatformClassLoader</code> 和 <code>BootClassLoader</code> 三个类都定义在 <code>jdk.internal.loader.ClassLoaders</code> 中。<code>BootClassLoader</code> 是由 Java 和 C++ 混合实现，所以有类的定义。</p>
</div>
<div class="paragraph">
<p><code>ClassLoader</code> 提供的资源加载的方法中的核心方法是 <code>ClassLoader#getResource(String name)</code>，它是基于用户应用程序的 ClassPath 搜索资源，遵循"资源加载的双亲委派模型"，资源名称必须使用路径分隔符 <code>/</code> 去分隔目录，但是不能以 <code>/</code> 作为资源名的起始字符，其他几个方法都是基于此方法进行衍生，添加复数操作等其他操作。<code>getResource(String name)</code> 方法不会显示抛出异常，当资源搜索失败的时候，会返回 <code>null</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何识别内部类？</p>
</li>
<li>
<p>如何获取内部类的正确类名？</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>1.1. 参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://www.throwable.club/2018/11/30/java-resource-load/">通过源码浅析Java中的资源加载 - Throwable&#8217;s Blog</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-09 23:46:32 +0800
</div>
</div>
</body>
</html>
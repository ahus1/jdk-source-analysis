<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>ThreadLocal</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_threadlocal">1. ThreadLocal</a>
<ul class="sectlevel2">
<li><a href="#_参考资料">1.1. 参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_threadlocal"><a class="anchor" href="#_threadlocal"></a>1. ThreadLocal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>原以为神秘兮兮的 <code>ThreadLocal</code> 是何方神圣？没想到，点开代码，竟然如此简单明了，直接上代码：</p>
</div>
<div class="listingblock">
<div class="title">Thread</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ThreadLocal</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

/**
 * Returns the value in the current thread's copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * @return the current thread's value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

/**
 * Sets the current thread's copy of this thread-local variable
 * to the specified value.  Most subclasses will have no need to
 * override this method, relying solely on the {@link #initialValue}
 * method to set the values of thread-locals.
 *
 * @param value the value to be stored in the current thread's copy of
 *        this thread-local.
 */
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value);
    }
}

static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as "stale entries" in the code that follows.
     */
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    // ……
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>简单解释一下：</p>
</div>
<div class="paragraph">
<p>当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法时，其实是调用的当前线程的 <code>ThreadLocal.ThreadLocalMap threadLocals</code> 变量的 <code>set(ThreadLocal&lt;?&gt; key, Object value)</code> 和 <code>Entry getEntry(ThreadLocal&lt;?&gt; key)</code>。还有一点需要稍加注意：虽然 <code>ThreadLocal.ThreadLocalMap</code> 名称是以 <code>Map</code> 结尾，但是它并没有实现 <code>Map</code> 接口，只是操作上有些类似。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/ThreadLocal-set-get.jpeg" alt="ThreadLocal set get">
</div>
</div>
<div class="paragraph">
<p>有一点需要特别注意：<code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用,而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 <code>null</code> 的 <code>Entry</code>。假如我们不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。使用完 <code>ThreadLocal</code> 方法后 最好手动调用 <code>remove()</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman.concurrent;

import org.junit.Test;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-03-09 20:20
 */
public class ThreadLocalTest {
    @Test
    public void test() {
        new Thread(new FirstApp()).start();
    }

    @Test
    public void testInheritableThreadLocal() {
        // TODO: InheritableThreadLocal
    }

    private static class FirstApp implements Runnable {
        private ThreadLocal&lt;String&gt; threadLocal
                = ThreadLocal.withInitial(() -&gt; "FirstApp-1");

        private ThreadLocal&lt;String&gt; threadLocal2
                = ThreadLocal.withInitial(() -&gt; "FirstApp-2");

        private SecondApp secondApp = new SecondApp();
        private ThridApp thridApp = new ThridApp();

        @Override
        public void run() {
            System.out.println(threadLocal.get());
            System.out.println(threadLocal2.get());
            new Thread(secondApp).start();
            thridApp.run();
        }
    }

    private static class SecondApp implements Runnable {
        private ThreadLocal&lt;String&gt; threadLocal
                = ThreadLocal.withInitial(() -&gt; "SecondApp");

        @Override
        public void run() {
            System.out.println(threadLocal.get());
        }
    }

    private static class ThridApp implements Runnable {
        private ThreadLocal&lt;String&gt; threadLocal
                = ThreadLocal.withInitial(() -&gt; getClass().getName());

        @Override
        public void run() {
            threadLocal.set("new-ThridApp-value");
            System.out.println(threadLocal.get());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关注一下： <code>java.lang.InheritableThreadLocal</code>。</p>
</div>
<div class="paragraph">
<p>JDK 的 <code>InheritableThreadLocal</code> 类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的 <code>ThreadLocal</code> 值传递已经没有意义，应用需要的实际上是把任务提交给线程池时的 <code>ThreadLocal</code> 值传递到 任务执行时。为了解决这个问题，阿里巴巴研发了 <a href="https://github.com/alibaba/transmittable-thread-local">alibaba/transmittable-thread-local</a> 库。</p>
</div>
<div class="sect2">
<h3 id="_参考资料"><a class="anchor" href="#_参考资料"></a>1.1. 参考资料</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_33-threadlocal%e5%8e%9f%e7%90%86">JavaGuide
之 ThreadLocal</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/dennyzhangdd/p/7978455.html">ThreadLocal终极源码剖析-一篇足矣！ - 只会一点java - 博客园</a></p>
</li>
<li>
<p><a href="http://www.throwable.club/2019/02/17/java-concurrency-threadlocal-source-code/">ThreadLocal源码分析-黄金分割数的使用 - Throwable&#8217;s Blog</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-09 23:46:32 +0800
</div>
</div>
</body>
</html>